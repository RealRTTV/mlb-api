#[macro_export]
#[doc(hidden)]
macro_rules! __stats__stat_type_definition {
    ($parent_name:ident => $vis:vis struct $name:ident { $stat_type:ident => [$($stat_group:ident),+] }) => {
		::pastey::paste! {
			#[derive(Debug, PartialEq, Eq, Clone)]
			$vis struct $name {
				$($vis [< $stat_group:snake >]: ::std::boxed::Box<$crate::stats::PossiblyFallback<<$crate::stats::[< $stat_type Stats >] as $crate::stats::StatTypeStats>::$stat_group>>),+
			}

			impl [<__ $parent_name Split Parser>] for $name {
				fn parse(parsed_stats: &mut $crate::stats::__ParsedStats) -> ::core::result::Result<Self, ::std::string::String> {
					Ok(Self {
						$([<$stat_group:snake>]: ::std::boxed::Box::new(
							$crate::stats::make_stat_split::<<$crate::stats::[< $stat_type Stats >] as $crate::stats::StatTypeStats>::$stat_group>(
								parsed_stats, ::core::stringify!([<$stat_type:lower_camel>]), $crate::stat_groups::StatGroup::$stat_group
							).map_err(|e| ::std::string::ToString::to_string(&e))?
						)),+
					})
				}
			}
    	}
	};
}

#[macro_export]
#[doc(hidden)]
macro_rules! __stats__base_hydration_text {
    ([$first_stat_type:ident $(, $stat_type:ident)* $(,)?] [$first_stat_group:ident $(, $stat_group:ident)* $(,)?]) => {
		::pastey::paste! {
			::core::concat!(
				"type=[",
				::core::stringify!([<$first_stat_type:lower_camel>]),
				$(",", ::core::stringify!([<$stat_type:lower_camel>]), )*
				"],group=[",
				::core::stringify!([<$first_stat_group:lower_camel>]),
				$(",", ::core::stringify!([<$stat_group:lower_camel>]), )*
				"]"
			)
		}
	};
}

// macro_rules! __stats__generate_needle_haystack_predicate {
//     ($name:ident ! ( $($needle:ident),+ ) $d:tt) => {
// 		#[macro_export]
// 		#[doc(hidden)]
// 		macro_rules! $name {
// 			$(
// 			([$needle $d (, $d haystack:ident)* $d (,)?] => { $d ($d t1:tt)* } else { $d ($d t2:tt)* }) => {
// 				$d ($d t1)*
// 			};
// 			)+
// 			([$d first:ident $d(, $d haystack:ident)* $d (,)?] => { $d ($d t1:tt)* } else { $d ($d t2:tt)* }) => {
// 				$name!([$d($d haystack),*] => { $d ($d t1)* } else { $d ($d t2)* });
// 			};
//     		([$d(,)?] => { $d ($d t1:tt)* } else { $d ($d t2:tt)* }) => { $d ($d t2)* };
// 		}
//
// 		#[doc(hidden)]
// 		pub use $name;
// 	};
// }

/// Generated by [`__stats__generate_needle_haystack_predicate`], cannot inline due to <https://github.com/rust-lang/rust/pull/52234>
#[macro_export]
#[doc(hidden)]
macro_rules! __stats__needle_haystack_metrics {
	([$($haystack:ident),+ $(,)?] => { $($t:tt)* }) => {
		$crate::__stats__needle_haystack_metrics!([$($haystack),+] => { $($t)* } else {});
	};
	([MetricLog $(, $haystack:ident)* $(,)?] => { $($t1:tt)* } else { $($t2:tt)* }) => {
		$($t1)*
	};
	([MetricAverages $(, $haystack:ident)* $(,)?] => { $($t1:tt)* } else { $($t2:tt)* }) => {
		$($t1)*
	};
	([$first:ident $(, $haystack:ident)* $(,)?] => { $($t1:tt)* } else { $($t2:tt)* }) => {
		$crate::__stats__needle_haystack_metrics!([$($haystack),*] => { $($t1)* } else { $($t2)* });
	};
	([$(,)?] => { $($t1:tt)* } else { $($t2:tt)* }) => { $($t2)* };
}

/// Generated by [`__stats__generate_needle_haystack_predicate`], cannot inline due to <https://github.com/rust-lang/rust/pull/52234>
#[macro_export]
#[doc(hidden)]
macro_rules! __stats__needle_haystack_date_range {
	([$($haystack:ident),+ $(,)?] => { $($t:tt)* }) => {
		$crate::__stats__needle_haystack_date_range!([$($haystack),+] => { $($t)* } else {});
	};
	([ByDateRange $(, $haystack:ident)* $(,)?] => { $($t1:tt)* } else { $($t2:tt)* }) => {
		$($t1)*
	};
	([$first:ident $(, $haystack:ident)* $(,)?] => { $($t1:tt)* } else { $($t2:tt)* }) => {
		$crate::__stats__needle_haystack_date_range!([$($haystack),*] => { $($t1)* } else { $($t2)* });
	};
	([$(,)?] => { $($t1:tt)* } else { $($t2:tt)* }) => { $($t2)* };
}

/// Generated by [`__stats__generate_needle_haystack_predicate`], cannot inline due to <https://github.com/rust-lang/rust/pull/52234>
#[macro_export]
#[doc(hidden)]
macro_rules! __stats__needle_haystack_situations {
	([$($haystack:ident),+ $(,)?] => { $($t:tt)* }) => {
		$crate::__stats__needle_haystack_situations!([$($haystack),+] => { $($t)* } else {});
	};
	([StatSplits $(, $haystack:ident)* $(,)?] => { $($t1:tt)* } else { $($t2:tt)* }) => {
		$($t1)*
	};
	([StatSplitsAdvanced $(, $haystack:ident)* $(,)?] => { $($t1:tt)* } else { $($t2:tt)* }) => {
		$($t1)*
	};
	([$first:ident $(, $haystack:ident)* $(,)?] => { $($t1:tt)* } else { $($t2:tt)* }) => {
		$crate::__stats__needle_haystack_situations!([$($haystack),*] => { $($t1)* } else { $($t2)* });
	};
	([$(,)?] => { $($t1:tt)* } else { $($t2:tt)* }) => { $($t2)* };
}

#[macro_export]
#[doc(hidden)]
macro_rules! __stats__request_data {
	(@ metrics [$($stat_type:ident),+] $(#[$m:meta])* $vis:vis struct $name:ident { $($field_tt:tt)* } $($impl_tt:tt)*) => {
		::pastey::paste! {
			$crate::__stats__needle_haystack_metrics! { [$($stat_type),+] => {
				$crate::__stats__request_data! { @ date_range [$($stat_type),+]
					$(#[$m])*
					$vis struct $name {
						$($field_tt)*
						metrics: ::std::vec::Vec<$crate::metrics::MetricId>,
					}
					$($impl_tt)*
					impl<S: [<$name:snake _builder>]::State> [<$name Builder>]<S> {
						pub fn metric(self, metric: impl ::core::convert::Into<$crate::metrics::MetricId>) -> [<$name Builder>]<[<$name:snake _builder>]::SetMetrics<S>>
						where
							S::Metrics: [<$name:snake _builder>]::IsUnset
						{
							self.metrics(::std::vec![::core::convert::Into::into(metric)])
						}
					}
				}
			} else {
				$crate::__stats__request_data! { @ date_range [$($stat_type),+]
					$(#[$m])*
					$vis struct $name {
						$($field_tt)*
					}
					$($impl_tt)*
				}
			}}
		}
	};
	(@ date_range [$($stat_type:ident),+] $(#[$m:meta])* $vis:vis struct $name:ident { $($field_tt:tt)* } $($impl_tt:tt)*) => {
		::pastey::paste! {
			$crate::__stats__needle_haystack_date_range!{[$($stat_type),+] => {
				$crate::__stats__request_data! { @ situations [$($stat_type),+]
					$(#[$m])*
					$vis struct $name {
						$($field_tt)*
						date_range: NaiveDateRange,
					}
					$($impl_tt)*
				}
			} else {
				$crate::__stats__request_data! { @ situations [$($stat_type),+]
					$(#[$m])*
					$vis struct $name {
						$($field_tt)*
					}
					$($impl_tt)*
				}
			}}
		}
	};
	(@ situations [$($stat_type:ident),+] $(#[$m:meta])* $vis:vis struct $name:ident { $($field_tt:tt)* } $($impl_tt:tt)*) => {
		::pastey::paste! {
			$crate::__stats__needle_haystack_situations!{[$($stat_type),+] => {
				// $crate::__stats__request_data! { @ batter_team [$($stat_type),+]
					$(#[$m])*
					$vis struct $name {
						$($field_tt)*
						situations: ::std::vec::Vec<$crate::situations::SituationCodeId>,
						#[builder(default)]
						situation_filter: $crate::situations::SituationCodeFilter,
					}
					$($impl_tt)*
					impl<S: [<$name:snake _builder>]::State> [<$name Builder>]<S> {
						pub fn situation(self, situation: impl ::core::convert::Into<$crate::situations::SituationCodeId>) -> [<$name Builder>]<[<$name:snake _builder>]::SetSituations<S>>
						where
							S::Situations: [<$name:snake _builder>]::IsUnset
						{
							self.situations(::std::vec![::core::convert::Into::into(situation)])
						}
					}
				// }
			} else {
				// $crate::__stats__request_data! { @ batter_team [$($stat_type),+]
					$(#[$m])*
					$vis struct $name {
						$($field_tt)*
					}
					$($impl_tt)*
				// }
			}}
		}
	};
    ($vis:vis $name:ident [$($stat_type:ident),+]) => {
		::pastey::paste! {
			$crate::__stats__request_data! { @ metrics [$($stat_type),+]
				#[derive(::bon::Builder)]
				#[builder(derive(Into))]
				#[allow(unused)]
				$vis struct [<$name RequestData>] {
					#[builder(default)]
					game_type: $crate::game_types::GameType,
					#[builder(into)]
					season: ::core::option::Option<$crate::season::SeasonId>, // todo: `seasons`?
					team_ids: ::core::option::Option<::std::vec::Vec<$crate::team::TeamId>>,
					sport_ids: ::core::option::Option<::std::vec::Vec<$crate::sport::SportId>>,
					league_ids: ::core::option::Option<::std::vec::Vec<$crate::league::LeagueId>>,
					#[builder(default)]
					player_pool: $crate::types::PlayerPool,

					// todo
					/*batter_team: TeamId,
					pitcher_team: TeamId,
					batter: PersonId,
					pitcher: PersonId,
					games_back: usize,
					days_back: usize*/
				}

				#[allow(unused)]
				impl<S: [<$name:snake _request_data_builder>]::State> [<$name RequestDataBuilder>]<S> {
					pub fn team_id(self, team_id: impl ::core::convert::Into<$crate::team::TeamId>) -> [<$name RequestDataBuilder>]<[<$name:snake _request_data_builder>]::SetTeamIds<S>>
					where
						S::TeamIds: [<$name:snake _request_data_builder>]::IsUnset
					{
						self.team_ids(::std::vec![::core::convert::Into::into(team_id)])
					}

					pub fn sport_id(self, sport_id: impl ::core::convert::Into<$crate::sport::SportId>) -> [<$name RequestDataBuilder>]<[<$name:snake _request_data_builder>]::SetSportIds<S>>
					where
						S::SportIds: [<$name:snake _request_data_builder>]::IsUnset
					{
						self.sport_ids(::std::vec![::core::convert::Into::into(sport_id)])
					}

					pub fn league_id(self, league_id: impl ::core::convert::Into<$crate::league::LeagueId>) -> [<$name RequestDataBuilder>]<[<$name:snake _request_data_builder>]::SetLeagueIds<S>>
					where
						S::LeagueIds: [<$name:snake _request_data_builder>]::IsUnset
					{
						self.league_ids(::std::vec![::core::convert::Into::into(league_id)])
					}
				}
			}

			impl ::core::fmt::Display for [<$name RequestData>] {
				fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
					use ::itertools::Itertools;

					::core::fmt::Write::write_fmt(f, ::core::format_args!("gameType={:?},", self.game_type))?;
					if let ::core::option::Option::Some(season)	= self.season {
						::core::fmt::Write::write_fmt(f, ::core::format_args!("season={},", season))?;
					}
					if let ::core::option::Option::Some(ids) = ::core::option::Option::as_ref(&self.team_ids) {
						::core::fmt::Write::write_fmt(f, ::core::format_args!("teamIds=[{}],", ids.iter().join(",")))?;
					}
					if let ::core::option::Option::Some(ids) = ::core::option::Option::as_ref(&self.sport_ids) {
						::core::fmt::Write::write_fmt(f, ::core::format_args!("sportIds=[{}],", ids.iter().join(",")))?;
					}
					if let ::core::option::Option::Some(ids) = ::core::option::Option::as_ref(&self.league_ids) {
						::core::fmt::Write::write_fmt(f, ::core::format_args!("leagueIds=[{}],", ids.iter().join(",")))?;
					}
					::core::fmt::Write::write_fmt(f, ::core::format_args!("playerPool={},", self.player_pool))?;

					$crate::__stats__needle_haystack_metrics! { [$($stat_type),+] => {
						::core::fmt::Write::write_fmt(f, ::core::format_args!("metrics={},", self.metrics.iter().join(",")))?;
					} else {}}
					$crate::__stats__needle_haystack_date_range! { [$($stat_type),+] => {
						::core::fmt::Write::write_fmt(f, ::core::format_args!("startDate={},endDate={},", self.date_range.start().format($crate::types::MLB_API_DATE_FORMAT), self.date_range.end().format($crate::types::MLB_API_DATE_FORMAT)))?;
					} else {}}
					$crate::__stats__needle_haystack_situations! { [$($stat_type),+] => {
						::core::fmt::Write::write_fmt(f, ::core::format_args!("sitCodes=[{}],combineSits={},", self.situations.iter().join(","), self.situation_filter == $crate::situations::SituationCodeFilter::All))?;
					} else {}}

					Ok(())
				}
			}

			$crate::__stats__needle_haystack_metrics! { [$($stat_type),+] => {} else {
				$crate::__stats__needle_haystack_date_range! { [$($stat_type),+] => {} else {
					$crate::__stats__needle_haystack_situations! { [$($stat_type),+] => {} else {
						impl ::core::default::Default for [<$name RequestData>] {
							fn default() -> Self {
								[<$name RequestDataBuilder>]::<[<$name:snake _request_data_builder>]::Empty>::build(Self::builder())
							}
						}
					}}
				}}
			}}

			impl $name {
				#[allow(unused)]
				pub fn builder() -> [<$name RequestDataBuilder>] {
					[<$name RequestData>]::builder()
				}
			}
		}
	};
}

/// Generates stat structs to be used in requests.
///
/// These are commonly associated with [`person_hydrations`](crate::person_hydrations) to create a [`PersonRequest`](crate::person::PersonRequest).
///
/// The list of [`StatType`](crate::stat_types::StatType)s can be found as implementors of [`StatTypeStats`](crate::stats::StatTypeStats).
///
/// The list of [`StatGroup`](crate::stat_groups::StatGroup)s can be found on its type.
///
/// # Examples
///```
///stats! {
///    pub struct MyStats {
///        [Season, Career] = [Hitting, Pitching]
///    }
///}
///
///---
///
///pub struct BasicStats {
///    season: BasicStatsSeasonSplit,
///    career: BasicStatsCareerSplit,
///}
///
///pub struct BasicStatsSeasonSplit {
///    hitting: Box<<SeasonStats as StatTypeStats>::Hitting>, // Season<HittingStats>
///    pitching: Box<<SeasonStats as StatTypeStats>::Pitching>, // Season<PitchingStats>
///}
///
///pub struct BasicStatsCareerSplit {
///    hitting: Box<<CareerStats as StatTypeStats>::Hitting>, // Career<HittingStats>
///    pitching: Box<<CareerStats as StatTypeStats>::Pitching>, // Career<PitchingStats>
///}
///```
#[macro_export]
macro_rules! stats {
    ($vis:vis struct $name:ident {
		[$($stat_type:ident),+] = $stat_groups:tt
	}) => {
		::pastey::paste! {
			#[derive(Debug, PartialEq, Eq, Clone)]
        	$vis struct $name {
				$($vis [<$stat_type:snake>]: [<$name $stat_type Split>],)*
			}

			#[doc(hidden)]
			trait [<__ $name Split Parser>] {
				fn parse(parsed_stats: &mut $crate::stats::__ParsedStats) -> ::core::result::Result<Self, ::std::string::String>
				where
					Self: Sized;
			}

			$($crate::__stats__stat_type_definition!($name => $vis struct [<$name $stat_type Split>] { $stat_type => $stat_groups });)+

			impl<'de> ::serde::Deserialize<'de> for $name {
				fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> ::core::result::Result<Self, D::Error>
				where
					Self: Sized
				{
					let mut parsed_stats: $crate::stats::__ParsedStats = <$crate::stats::__ParsedStats as ::serde::Deserialize>::deserialize(deserializer)?;

					Ok(Self {
						$([<$stat_type:snake>]: <[<$name $stat_type Split>] as [<__ $name Split Parser>]>::parse(&mut parsed_stats).map_err(<D::Error as ::serde::de::Error>::custom)?),+
					})
				}
			}

			impl $crate::hydrations::Hydrations for $name {}

			$crate::__stats__request_data!($vis $name [$($stat_type),+]);

			impl $crate::hydrations::HydrationText for $name {
				type RequestData = [<$name RequestData>];

                fn hydration_text(data: &<Self as $crate::hydrations::HydrationText>::RequestData) -> ::std::borrow::Cow<'static, str> {
					let base: &'static str = $crate::__stats__base_hydration_text!([$($stat_type),+] $stat_groups);
					let data: ::std::string::String = ::std::string::ToString::to_string(data);
					if str::is_empty(&*data) {
						::std::borrow::Cow::Borrowed(base)
					} else {
						::std::borrow::Cow::Owned(::std::format!("{base},{data}"))
					}
				}
            }
		}
    };
}
